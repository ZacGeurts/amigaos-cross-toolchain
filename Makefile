# This Makefile builds a cross-compilation toolchain for multiple target systems.
# Copyright (c) 2025 Zachary Geurts, MIT License
# Configure targets and components in versions.mk; do not edit this file.

DISPLAY_AS_LOG ?= 0
ENABLE_STATIC ?= 0
include versions.mk

# Targets: Dynamically extract target systems from versions.mk, excluding common and linux,windows,macos
TARGETS := $(sort $(foreach comp,$(filter VERSIONS[%],$(.VARIABLES)),$(word 5,$(subst =, ,$(value $(comp))))))
TARGETS := $(filter-out common linux,windows,macos,$(TARGETS))
# Filter out targets with no components
TARGETS := $(foreach target,$(TARGETS),$(if $(foreach comp,$(filter VERSIONS[%],$(.VARIABLES)),$(filter $(target),$(word 5,$(subst =, ,$(value $(comp)))))),$(target)))

# Directories: Define paths for build, install, download, and log directories
TOP := $(abspath .)
DOWNLOAD := $(TOP)/downloads
BUILD := $(TOP)/build
LOGS := $(TOP)/logs
SOURCES := $(BUILD)/sources
STAMPS := $(BUILD)/stamps
TMPDIR := $(BUILD)/tmp

# Target-specific variables
$(foreach target,$(TARGETS),\
  $(eval $(target)_TARGET := $(if $(filter amigaos-ppc amigaos-m68k,$(target)),$(subst amigaos-,,$(target))-amigaos,$(target)))\
  $(eval $(target)_BUILD := $(BUILD)/$(target))\
  $(eval $(target)_DOWNLOAD := $(DOWNLOAD)/$(target))\
  $(eval $(target)_PREFIX := $(if $(PREFIX),$(PREFIX)/$(target),$(BUILD)/install/$(target)))\
  $(eval $(target)_STAMPS := $(STAMPS)/$(target))\
  $(eval $(target)_COMPONENTS := $(sort $(foreach comp,$(filter VERSIONS[%],$(.VARIABLES)),$(if $(filter $(target),$(word 5,$(subst =, ,$(value $(comp))))),$(patsubst VERSIONS[%,%,$(subst ],,$(comp)))))))\
  $(eval $(target)_COMPONENTS := $(if $(filter 1,$(INCLUDE_UNCOMMON)),$($(target)_COMPONENTS),$(filter-out $(foreach comp,$(filter VERSIONS[%],$(.VARIABLES)),$(if $(filter linux,windows,macos,$(word 5,$(subst =, ,$(value $(comp))))),$(patsubst VERSIONS[%,%,$(subst ],,$(comp))))),$($(target)_COMPONENTS)))))

# Error and message tracking
FIRST_ERROR ?=
RECENT_ERROR ?=
LAST_MESSAGE ?=

# Validate components: Ensure defined components have VERSIONS entries
$(foreach target,$(TARGETS),\
  $(foreach comp,$($(target)_COMPONENTS),\
	$(if $(VERSIONS[$(comp)]),,$(error ERROR: Version for component '$(comp)' not defined in versions.mk for target $(target)))))

# Configuration flags: Component-specific configure options
CONFIG_FLAGS[bison] := --disable-nls
CONFIG_FLAGS[flex] := --disable-nls
CONFIG_FLAGS[gawk] := --disable-extensions
CONFIG_FLAGS[gcc] := --disable-nls --enable-languages=c,c++ --disable-libstdcxx-pch --disable-tls
CONFIG_FLAGS[m4] := CFLAGS="-Wno-error" --with-gmp=$(PREFIX) --with-mpfr=$(PREFIX)
CONFIG_FLAGS[mpc] := --with-gmp=$(PREFIX)
CONFIG_FLAGS[mpfr] := --with-gmp=$(PREFIX)
CONFIG_FLAGS[texinfo] := --disable-perl-api
STATIC_FLAGS := $(if $(filter 1,$(ENABLE_STATIC)),--enable-static --disable-shared,--enable-shared --disable-static)

# Dependencies: Build dependencies for components
DEPEND[autoconf] := m4
DEPEND[automake] := autoconf
DEPEND[binutils] := automake
DEPEND[bison] := m4
DEPEND[clib2] := gcc
DEPEND[gcc] := binutils mpc mpfr gmp
DEPEND[libdebug] := vbcc-bin
DEPEND[libnix] := vbcc-bin
DEPEND[libtool] := autoconf
DEPEND[mpc] := mpfr
DEPEND[mpfr] := gmp
DEPEND[texinfo] := automake
DEPEND[sdl] := opengl
DEPEND[sdl2] := opengl opengles

# Target-specific dependency mapping
$(foreach target,$(TARGETS),\
  $(foreach comp,$($(target)_COMPONENTS),\
	$(eval DEPEND_$(target)_$(comp) := $(foreach dep,$(DEPEND[$(comp)]),$(if $(filter $(dep),$($(target)_COMPONENTS)),$(dep))))))


# Common components (available to all platforms)
COMMON_COMPONENTS := $(sort $(foreach comp,$(filter VERSIONS[%],$(.VARIABLES)),$(if $(filter common,$(word 5,$(subst =, ,$(value $(comp))))),$(patsubst VERSIONS[%,%,$(subst ],,$(comp))))))

# Tools: Define build and archive tools
TOOLS := CC=gcc CXX=g++ MAKE=make CURL=curl PATCH=patch BISON=bison FLEX=flex SVN=svn GIT=git PERL=perl GPERF=gperf YACC=yacc HELP2MAN=help2man AUTOPOINT=autopoint
ARCHIVE_TOOLS := GZIP=gzip BZIP2=bzip2 XZ=xz LHA=lha 7Z=7z
$(foreach t,$(TOOLS) $(ARCHIVE_TOOLS),$(eval $(word 1,$(subst =, ,$(t))) := $(word 2,$(subst =, ,$(t)))))
ARCHIVE_TOOL_LHA := $(shell command -v lhasa || echo lha)
ARCHIVE_TOOL_7Z := $(shell command -v 7z || echo 7z)

# OS detection: Handle host OS-specific commands
OS := $(shell uname -s)
OS_NAME := $(if $(filter Linux,$(OS)),Linux,$(if $(filter Darwin,$(OS)),macOS,$(if $(filter Windows_NT,$(OS)),Windows,Unknown)))
SHELL := $(if $(filter Windows_NT,$(OS)),cmd.exe,/bin/sh)
MKDIR := $(if $(filter Windows_NT,$(OS)),mkdir,mkdir -p)
CP := $(if $(filter Windows_NT,$(OS)),copy /Y,cp -r)
RM := $(if $(filter Windows_NT,$(OS)),del /Q,rm -rf)
TOUCH := $(if $(filter Windows_NT,$(OS)),echo. >,touch)
CHMOD := $(if $(filter Windows_NT,$(OS)),attrib,chmod)
PATHSEP := $(if $(filter Windows_NT,$(OS)),\\,/)
ECHO := $(if $(filter Windows_NT,$(OS)),echo,echo)
TIMESTAMP := $(if $(filter Windows_NT,$(OS)),time /T,date +%H:%M:%S)
DATE := $(if $(filter Windows_NT,$(OS)),date /T,date +%Y-%m-%d)

# Logging: Output messages to console and logs/summary.log (if DISPLAY_AS_LOG=0)
define LOG_MESSAGE
	@$(ECHO) "[$$($(TIMESTAMP))] $1"
	$(if $(filter 0,$(DISPLAY_AS_LOG)),\
		@$(MKDIR) $(LOGS); \
		@$(ECHO) "[$$($(TIMESTAMP))] $1" >> $(LOGS)/summary.log)
	$(eval LAST_MESSAGE := [$$($(TIMESTAMP))] $1)
endef
define LOG_ERROR
	@$(ECHO) "[$$($(TIMESTAMP))] ERROR: $1"
	$(if $(filter 0,$(DISPLAY_AS_LOG)),\
		@$(MKDIR) $(LOGS); \
		@$(ECHO) "[$$($(TIMESTAMP))] ERROR: $1" >> $(LOGS)/summary.log)
	$(eval RECENT_ERROR := [$$($(TIMESTAMP))] ERROR: $1)
	$(if $(filter-out $(FIRST_ERROR),),$(eval FIRST_ERROR := [$$($(TIMESTAMP))] ERROR: $1))
endef

# Progress ticker: Notify every 60 seconds with start and elapsed time
define PROGRESS_TICKER
	@( \
		$(MKDIR) $(LOGS); \
		start_time=$$(date +%s 2>/dev/null || echo 0); \
		start_display=$$($(TIMESTAMP)); \
		while true; do \
			current_time=$$(date +%s 2>/dev/null || echo $$((start_time + 60))); \
			elapsed=$$((current_time - start_time)); \
			elapsed_h=$$((elapsed / 3600)); \
			elapsed_m=$$(( (elapsed % 3600) / 60 )); \
			elapsed_s=$$((elapsed % 60)); \
			elapsed_display=$$(printf "%02d:%02d:%02d" $$elapsed_h $$elapsed_m $$elapsed_s); \
			if [ $$elapsed -ge 60 ]; then \
				$(ECHO) "[$$($(TIMESTAMP))] [PROGRESS] Operation still running (started $$start_display, elapsed $$elapsed_display)." | \
				$(if $(filter 0,$(DISPLAY_AS_LOG)),tee -a $(LOGS)/summary.log,cat); \
				$(eval LAST_MESSAGE := [$$($(TIMESTAMP))] [PROGRESS] Operation still running (started $$start_display, elapsed $$elapsed_display).); \
				start_time=$$current_time; \
			fi; \
			if ! ps -p $$PPID >/dev/null 2>&1; then exit 0; fi; \
			sleep 10; \
		done \
	) &
	TICKER_PID=$$!
endef
define STOP_TICKER
	@if [ -n "$(TICKER_PID)" ]; then \
		kill $(TICKER_PID) 2>/dev/null || true; \
		wait $(TICKER_PID) 2>/dev/null || true; \
		TICKER_PID=; \
	fi
endef

# Download failure prompt
define HANDLE_DOWNLOAD_FAILURE
	$(call LOG_ERROR,Download failed for $$URL after 3 retries. Please place $$TARGET in $$DOWNLOAD_DIR.); \
	$(STOP_TICKER); \
	exit 1
endef

.DEFAULT_GOAL := help
.PHONY: all check clean clean-download debug_components debug_rules help check_headers check_tools $(TARGETS)

all: $(TARGETS)
clean: ; $(RM) $(BUILD) $(if $(PREFIX),$(PREFIX)); $(call LOG_MESSAGE,Cleaned build and prefix directories)
clean-download:
	@if [ -d "$(DOWNLOAD)" ]; then \
		$(call LOG_MESSAGE,WARNING: This will delete the entire $(DOWNLOAD) folder, including all user-provided files.); \
		$(call LOG_MESSAGE,Please back up any important files in $(DOWNLOAD) before proceeding.); \
		if [ "$(OS)" = "Windows_NT" ]; then \
			set /p response=Proceed with deletion? [y/N] ; \
			if /i "!response!"=="y" ( \
				$(RM) $(DOWNLOAD) && $(call LOG_MESSAGE,$(DOWNLOAD) folder deleted.) \
			) else ( \
				$(call LOG_MESSAGE,Operation cancelled.) && exit /b 1 \
			); \
		else \
			read -p "Proceed with deletion? [y/N] " response; \
			if [ "$$response" = "y" ] || [ "$$response" = "Y" ]; then \
				$(RM) $(DOWNLOAD) && $(call LOG_MESSAGE,$(DOWNLOAD) folder deleted.); \
			else \
				$(call LOG_MESSAGE,Operation cancelled.); exit 1; \
			fi; \
		fi; \
	else \
		$(call LOG_MESSAGE,$(DOWNLOAD) does not exist, nothing to clean.); \
	fi

# Directory creation
DIRS := $(BUILD) $(DOWNLOAD) $(LOGS) $(SOURCES) $(STAMPS) $(TMPDIR) $(foreach target,$(TARGETS),$($(target)_BUILD) $($(target)_DOWNLOAD) $($(target)_PREFIX) $($(target)_STAMPS))
$(DIRS): ; $(MKDIR) $@ && $(call LOG_MESSAGE,Created directory $@)

# Build utilities
define BUILD_AUTOTOOLS
	$(call LOG_MESSAGE,Configuring and building $1 in $2)
	$(MKDIR) $2
	cd $2
	[ -f autogen.sh ] || { echo "#!/bin/bash\nset -e\nlibtoolize --force --copy\naclocal -I m4\nautoconf\nautoheader\n[ -f Makefile.am ] && automake --add-missing --copy --foreign" > autogen.sh; $(CHMOD) +x autogen.sh; }
	[ -f bootstrap ] || $(CP) autogen.sh bootstrap
	$(PROGRESS_TICKER)
	./bootstrap
	./configure --prefix=$3 $(STATIC_FLAGS) $4
	$(MAKE)
	$(MAKE) install $(if $(filter 0,$(DISPLAY_AS_LOG)),>$(LOGS)/$1.log 2>&1,)
	$(STOP_TICKER)
	$(TOUCH) $5/$1
	$(call LOG_MESSAGE,Successfully built and installed $1. $(if $(filter 0,$(DISPLAY_AS_LOG)),Log saved to $(LOGS)/$1.log,Output displayed on screen))
endef

define BUILD_AUTOTOOLS_RULE
$1_STAMPS/$2: $(addprefix $1_STAMPS/,$(DEPEND_$(target)_$2)) $(call BUILD_COMPONENT_DEPS,$2,$1) | $1_BUILD
	$(call BUILD_UNPACK,$(call BUILD_COMPONENT_DEPS,$2,$1),$2$(if $(VERSIONS[$2]),-$(VERSIONS[$2])),$1_BUILD)
	$(call BUILD_AUTOTOOLS,$2,$($1_BUILD)/$2$(if $(VERSIONS[$2]),-$(VERSIONS[$2])),$($1_PREFIX),$(CONFIG_FLAGS[$2]),$1_STAMPS)
endef

define BUILD_COMPONENT
$1_STAMPS/$2: $(addprefix $1_STAMPS/,$(DEPEND_$(target)_$2)) $(call BUILD_COMPONENT_DEPS,$2,$1) | $1_BUILD
	$(MKDIR) $1_BUILD/$2
	$(call LOG_MESSAGE,Created build directory $1_BUILD/$2)
	$(call BUILD_COMPONENT_BUILD,$2,$1)
	$(TOUCH) $@
	$(call LOG_MESSAGE,Completed processing $2 for $1)
endef

define BUILD_COMPONENT_BUILD
	$(eval BUILD_RULE := $(BUILD_$1))
	$(eval BUILD_TYPE := $(word 1,$(subst :, ,$(BUILD_RULE))))
	$(eval BUILD_CMD := $(word 2,$(subst :, ,$(BUILD_RULE))))
	$(if $(BUILD_RULE),\
		$(call LOG_MESSAGE,Building $1 for $2 (type: $(BUILD_TYPE))) \
		$(call BUILD_UNPACK,$(call BUILD_COMPONENT_DEPS,$1,$2),$1$(if $(VERSIONS[$1]),-$(VERSIONS[$1])),$2_BUILD) \
		$(PROGRESS_TICKER) \
		$(eval PREFIX := $($(2)_PREFIX)) \
		$(eval BUILD_DIR := $($(2)_BUILD)) \
		$(eval LOG_FILE := $(LOGS)/$1.log) \
		$(BUILD_CMD) $(if $(filter 0,$(DISPLAY_AS_LOG)),,>>$(LOG_FILE) 2>&1) \
		$(STOP_TICKER) \
		$(call LOG_MESSAGE,Successfully built and installed $1. $(if $(filter 0,$(DISPLAY_AS_LOG)),Log saved to $(LOGS)/$1.log,Output displayed on screen)),\
		$(call LOG_MESSAGE,Warning: No build rule for $1, attempting autotools) \
		$(call BUILD_UNPACK,$(call BUILD_COMPONENT_DEPS,$1,$2),$1$(if $(VERSIONS[$1]),-$(VERSIONS[$1])),$2_BUILD) \
		$(PROGRESS_TICKER) \
		cd $2_BUILD/$1$(if $(VERSIONS[$1]),-$(VERSIONS[$1])) \
		./configure --prefix=$($2_PREFIX) $(STATIC_FLAGS) $(CONFIG_FLAGS[$1]) \
		$(MAKE) \
		$(MAKE) install $(if $(filter 0,$(DISPLAY_AS_LOG)),>$(LOGS)/$1.log 2>&1,) \
		$(STOP_TICKER) \
		$(call LOG_MESSAGE,Successfully built and installed $1. $(if $(filter 0,$(DISPLAY_AS_LOG)),Log saved to $(LOGS)/$1.log,Output displayed on screen)))
endef

define BUILD_COMPONENT_DEPS
	$(call FIND_COMPONENT_FILE,$1,$2)
endef

define FIND_COMPONENT_FILE
	$(call PARSE_URL,$(filter $1=%,$(URLS)))
	$(eval MATCHING_FILES := $(wildcard $(DOWNLOAD_DIR)/$1-$(VERSIONS[$1]).tar.gz $(DOWNLOAD_DIR)/$1-$(VERSIONS[$1]).tgz $(DOWNLOAD_DIR)/$1-$(VERSIONS[$1]).tar.bz2 $(DOWNLOAD_DIR)/$1-$(VERSIONS[$1]).tbz2 $(DOWNLOAD_DIR)/$1-$(VERSIONS[$1]).tar.xz $(DOWNLOAD_DIR)/$1-$(VERSIONS[$1]).zip $(DOWNLOAD_DIR)/$1.lha))
	$(eval SELECTED_FILE := $(if $(filter git,$(VERSION)),$(DOWNLOAD_DIR)/$1,$(if $(MATCHING_FILES),$(firstword $(MATCHING_FILES)),$(DOWNLOAD_DIR)/$(TARGET))))
	$(if $(filter 0.0.0,$(VERSIONS[$1])),\
		$(eval LATEST_FILES := $(sort $(wildcard $(DOWNLOAD_DIR)/$1-*.tar.gz $(DOWNLOAD_DIR)/$1-*.tgz $(DOWNLOAD_DIR)/$1-*.tar.bz2 $(DOWNLOAD_DIR)/$1-*.tbz2 $(DOWNLOAD_DIR)/$1-*.tar.xz $(DOWNLOAD_DIR)/$1-*.zip $(DOWNLOAD_DIR)/$1-*.lha)))\
		$(eval SELECTED_FILE := $(if $(LATEST_FILES),$(lastword $(LATEST_FILES)),$(DOWNLOAD_DIR)/$(TARGET)))\
		$(if $(LATEST_FILES),$(call LOG_MESSAGE,Using latest file for $1 (0.0.0): $(lastword $(LATEST_FILES))),$(call LOG_ERROR,No files found for $1 in $(DOWNLOAD_DIR). Will attempt to download $(TARGET).)),\
		$(if $(MATCHING_FILES),$(call LOG_MESSAGE,Found user-provided file for $1: $(firstword $(MATCHING_FILES))),\
			$(eval LATEST_FILES := $(sort $(wildcard $(DOWNLOAD_DIR)/$1-*.tar.gz $(DOWNLOAD_DIR)/$1-*.tgz $(DOWNLOAD_DIR)/$1-*.tar.bz2 $(DOWNLOAD_DIR)/$1-*.tbz2 $(DOWNLOAD_DIR)/$1-*.tar.xz $(DOWNLOAD_DIR)/$1-*.zip $(DOWNLOAD_DIR)/$1-*.lha)))\
			$(eval SELECTED_FILE := $(if $(LATEST_FILES),$(lastword $(LATEST_FILES)),$(DOWNLOAD_DIR)/$(TARGET)))\
			$(if $(LATEST_FILES),$(call LOG_MESSAGE,Specified file for $1 not found. Using latest file: $(lastword $(LATEST_FILES))),$(call LOG_ERROR,No files found for $1 in $(DOWNLOAD_DIR). Will attempt to download $(TARGET).))))
	$(SELECTED_FILE)
endef

define FETCH_SOURCE
	$(call LOG_MESSAGE,Starting source fetch for $1)
	$(MKDIR) $2
	for pkg in $1; do \
		$(call PARSE_URL,$$pkg); \
		if [ "$$VERSION" = "git" ]; then \
			if [ -d "$$DOWNLOAD_DIR/$$TARGET" ]; then \
				$(call LOG_MESSAGE,Repository $$TARGET already exists in $$DOWNLOAD_DIR); \
			else \
				$(call LOG_MESSAGE,Cloning $$URL); \
				$(PROGRESS_TICKER); \
				$(GIT) clone "$$URL" "$$DOWNLOAD_DIR/$$TARGET" $(if $(filter 0,$(DISPLAY_AS_LOG)),>>$(LOGS)/$$TARGET.log 2>&1,); \
				(cd "$$DOWNLOAD_DIR/$$TARGET" && $(GIT) submodule update --init --recursive $(if $(filter 0,$(DISPLAY_AS_LOG)),>>$(LOGS)/$$TARGET.log 2>&1,)); \
				$(STOP_TICKER); \
				$(MKDIR) "$(SOURCES)/$$TARGET"; \
				$(CP) "$$DOWNLOAD_DIR/$$TARGET"/* "$(SOURCES)/$$TARGET/" $(if $(filter 0,$(DISPLAY_AS_LOG)),>>$(LOGS)/$$TARGET.log 2>&1,); \
				$(call LOG_MESSAGE,Successfully cloned $$TARGET); \
			fi; \
		else \
			$(eval MATCHING_FILES := $(wildcard $$DOWNLOAD_DIR/$$NAME-$$VERSION.tar.gz $$DOWNLOAD_DIR/$$NAME-$$VERSION.tgz $$DOWNLOAD_DIR/$$NAME-$$VERSION.tar.bz2 $$DOWNLOAD_DIR/$$NAME-$$VERSION.tbz2 $$DOWNLOAD_DIR/$$NAME-$$VERSION.tar.xz $$DOWNLOAD_DIR/$$NAME-$$VERSION.zip $$DOWNLOAD_DIR/$$NAME.lha)) \
			if [ -n "$$MATCHING_FILES" ]; then \
				$(call LOG_MESSAGE,Using existing file for $$NAME: $$(firstword $$MATCHING_FILES)); \
			else \
				$(eval LATEST_FILES := $(sort $(wildcard $$DOWNLOAD_DIR/$$NAME-*.tar.gz $$DOWNLOAD_DIR/$$NAME-*.tgz $$DOWNLOAD_DIR/$$NAME-*.tar.bz2 $$DOWNLOAD_DIR/$$NAME-*.tbz2 $$DOWNLOAD_DIR/$$NAME-*.tar.xz $$DOWNLOAD_DIR/$$NAME-*.zip $$DOWNLOAD_DIR/$$NAME.lha))) \
				if [ "$$VERSION" = "0.0.0" ] && [ -n "$$LATEST_FILES" ]; then \
					$(call LOG_MESSAGE,Using latest file for $$NAME (0.0.0): $$(lastword $$LATEST_FILES)); \
				elif [ -n "$$LATEST_FILES" ] && [ -z "$$MATCHING_FILES" ]; then \
					$(call LOG_MESSAGE,Specified file for $$NAME not found. Using latest file: $$(lastword $$LATEST_FILES)); \
				else \
					$(call LOG_MESSAGE,Downloading $$URL to $$DOWNLOAD_DIR/$$TARGET); \
					$(PROGRESS_TICKER); \
					for i in 1 2 3; do \
						if $(CURL) -L -f -o "$$DOWNLOAD_DIR/$$TARGET" "$$URL" $(if $(filter 0,$(DISPLAY_AS_LOG)),>>$(LOGS)/$$NAME.log 2>&1,); then \
							$(call LOG_MESSAGE,Successfully downloaded $$TARGET); \
							break; \
						else \
							$(call LOG_MESSAGE,Retry $$i failed for $$URL); \
							if [ $$i -eq 3 ]; then \
								$(call HANDLE_DOWNLOAD_FAILURE); \
							fi; \
							sleep 2; \
						fi; \
					done; \
					$(STOP_TICKER); \
				fi; \
			fi; \
		fi; \
	done
	$(TOUCH) $2
	$(call LOG_MESSAGE,Completed source fetch for $1)
endef

define PARSE_URL
	$(eval NAME := $(word 1,$(subst =, ,$1)))
	$(eval VERSION := $(word 2,$(subst =, ,$1)))
	$(eval URL := $(word 3,$(subst =, ,$1)))
	$(eval TARGET := $(word 4,$(subst =, ,$1)))
	$(eval PLATFORM := $(word 5,$(subst =, ,$1)))
	$(eval DOWNLOAD_DIR := $(if $(filter common,$(PLATFORM)),$(DOWNLOAD),$(DOWNLOAD)/$(PLATFORM)))
	$(eval EXTENSION := $(if $(filter git,$(VERSION)),git,$(suffix $(TARGET))))
	$(call LOG_MESSAGE,Parsed URL for $$NAME: version=$$VERSION, target=$$TARGET, platform=$$PLATFORM)
endef

define BUILD_UNPACK
	$(call LOG_MESSAGE,Unpacking $1 to $3)
	$(MKDIR) $3
	cd $3
	$(PROGRESS_TICKER)
	case "$(suffix $1)" in \
		.lha) $(ARCHIVE_TOOL_LHA) x "$1" $(if $(filter 0,$(DISPLAY_AS_LOG)),>>$(LOGS)/$2.log 2>&1,);; \
		.tar.gz|.tgz) $(GZIP) -d "$1" -c | tar -x $(if $(filter 0,$(DISPLAY_AS_LOG)),>>$(LOGS)/$2.log 2>&1,);; \
		.tar.bz2|.tbz2) $(BZIP2) -d "$1" -c | tar -x $(if $(filter 0,$(DISPLAY_AS_LOG)),>>$(LOGS)/$2.log 2>&1,);; \
		.tar.xz) $(XZ) -d "$1" -c | tar -x $(if $(filter 0,$(DISPLAY_AS_LOG)),>>$(LOGS)/$2.log 2>&1,);; \
		.zip) $(ARCHIVE_TOOL_7Z) x "$1" $(if $(filter 0,$(DISPLAY_AS_LOG)),>>$(LOGS)/$2.log 2>&1,);; \
		.git) $(MKDIR) $2; $(CP) "$1"/* $2/ $(if $(filter 0,$(DISPLAY_AS_LOG)),>>$(LOGS)/$2.log 2>&1,);; \
		*) $(STOP_TICKER); $(call LOG_ERROR,Unsupported extension: $(suffix $1)); exit 1;; \
	esac
	$(STOP_TICKER)
	$(call LOG_MESSAGE,Successfully unpacked $2 to $3)
endef

# Download rules
URLS := $(foreach comp,$(filter VERSIONS[%],$(.VARIABLES)),$(subst VERSIONS[,,$(subst ],,$(comp))=$(value $(comp))))
DOWNLOAD_FILES := $(foreach pkg,$(URLS),$(call FIND_COMPONENT_FILE,$(word 1,$(subst =, ,$(pkg)))))
$(DOWNLOAD)/%: | $(LOGS)
	$(call FETCH_SOURCE,$(filter %=$* %=common,$(URLS)),$(DOWNLOAD))
$(foreach target,$(TARGETS),$(eval $($(target)_DOWNLOAD)/%: | $($(target)_DOWNLOAD)
	$(call FETCH_SOURCE,$(filter %=$* %=$(target),$(URLS)),$($(target)_DOWNLOAD))))
$(DOWNLOAD)/.downloaded: $(filter $(DOWNLOAD)/%,$(DOWNLOAD_FILES)) | $(DOWNLOAD)
	$(TOUCH) $@ && $(call LOG_MESSAGE,Marked $(DOWNLOAD) as processed)
$(foreach target,$(TARGETS),$(eval $($(target)_DOWNLOAD)/.downloaded: $(filter $($(target)_DOWNLOAD)/%,$(DOWNLOAD_FILES)) | $($(target)_DOWNLOAD)
	$(TOUCH) $@ && $(call LOG_MESSAGE,Marked $($(target)_DOWNLOAD) as processed))))

# Debug targets
debug_components:
	$(call LOG_MESSAGE,Listing components)
	$(foreach target,$(TARGETS),$(ECHO) "$(target) components: $($(target)_COMPONENTS)" | $(if $(filter 0,$(DISPLAY_AS_LOG)),tee -a $(LOGS)/summary.log,cat))
	$(ECHO) "Common components: $(COMMON_COMPONENTS)" | $(if $(filter 0,$(DISPLAY_AS_LOG)),tee -a $(LOGS)/summary.log,cat)
	$(ECHO) "Autotools components: $(filter $(AUTOTOOLS_COMPONENTS),$(foreach target,$(TARGETS),$($(target)_COMPONENTS)))" | $(if $(filter 0,$(DISPLAY_AS_LOG)),tee -a $(LOGS)/summary.log,cat)
	$(ECHO) "Non-autotools components: $(filter-out $(AUTOTOOLS_COMPONENTS),$(foreach target,$(TARGETS),$($(target)_COMPONENTS)))" | $(if $(filter 0,$(DISPLAY_AS_LOG)),tee -a $(LOGS)/summary.log,cat)
debug_rules:
	$(call LOG_MESSAGE,Listing generated rules)
	$(foreach target,$(TARGETS),$(ECHO) "$(target) rules:" | $(if $(filter 0,$(DISPLAY_AS_LOG)),tee -a $(LOGS)/summary.log,cat);$(foreach comp,$($(target)_COMPONENTS),$(ECHO) "  $(comp): $($(target)_STAMPS)/$(comp)" | $(if $(filter 0,$(DISPLAY_AS_LOG)),tee -a $(LOGS)/summary.log,cat)))

# Apply rules
AUTOTOOLS_COMPONENTS := autoconf automake bison flex busybox expat gawk gmp libbz2 libffi libiconv giflib libintl libjpeg libmpg123 libogg libpng libsndfile libtheora libvorbis libxml2 m4 make mpc mpfr pkg-config texinfo zlib
$(foreach target,$(TARGETS),$(foreach comp,$(filter $(AUTOTOOLS_COMPONENTS),$($(target)_COMPONENTS)),$(eval $(call BUILD_AUTOTOOLS_RULE,$(target),$(comp)))))
$(foreach target,$(TARGETS),$(foreach comp,$(filter-out $(AUTOTOOLS_COMPONENTS),$($(target)_COMPONENTS)),$(eval $(call BUILD_COMPONENT,$(target),$(comp)))))

# Tool validation
CHECK_TOOLS := $(subst :, ,$(TOOLS) $(ARCHIVE_TOOLS)) lhasa
$(CHECK_TOOLS): ; @command -v $@ >/dev/null || { $(call LOG_ERROR,Tool '$@' not found. Install on $(OS_NAME): $(if $(filter Linux,$(OS)),sudo apt-get install $(subst ARCHIVE_,,$@),$(if $(filter macOS,$(OS)),brew install $(subst ARCHIVE_,,$@),$(subst ARCHIVE_,,$@)))); exit 2; }

# Header check
$(TMPDIR)/check.c: | $(TMPDIR)
	$(ECHO) "#include <ncurses.h>\nint main() { return 0; }" > $@
	$(call LOG_MESSAGE,Created test file $@)
check_headers: check_tools $(TMPDIR)/check.c
	$(CC) $(TMPDIR)/check.c -o /dev/null && $(call LOG_MESSAGE,ncurses headers verified) || \
	{ $(call LOG_ERROR,Missing ncurses headers. Install on $(OS_NAME): $(if $(filter Linux,$(OS)),sudo apt-get install libncurses-dev,$(if $(filter macOS,$(OS)),brew install ncurses,libncurses))); exit 2; }

# Check target
check: check_headers
	$(call LOG_MESSAGE,Setup check completed. Run 'make check' or 'make <target>' to build.)

# Main targets
$(TARGETS): %: $(addprefix %_%_STAMPS/,$(%_COMPONENTS)) | check_headers
	$(call LOG_MESSAGE,$@ toolchain built successfully)

# Help target
help:
	$(call LOG_MESSAGE,=== Cross-Compilation Toolchain ===)
	$(ECHO) "Host OS: $(OS_NAME)" | $(if $(filter 0,$(DISPLAY_AS_LOG)),tee -a $(LOGS)/log,cat)
	$(ECHO) "Build Directory: $(BUILD)" | $(if $(filter 0,$(DISPLAY_AS_LOG)),tee -a $(LOGS)/log,cat)
	$(ECHO) "Download Directory: $(DOWNLOAD)" | $(if $(filter 0,$(DISPLAY_AS_LOG)),tee -a $(LOGS)/log,cat)
	$(ECHO) "Log Directory: $(LOGS)" | $(if $(filter 0,$(DISPLAY_AS_LOG)),tee -a $(LOGS)/log,cat)
	$(ECHO) "Install Prefixes: $(foreach target,$(TARGETS),$(target): $($(target)_PREFIX))" | $(if $(filter 0,$(DISPLAY_AS_LOG)),tee -a $(LOGS)/log,cat)
	$(ECHO) "Library Type: $(if $(filter 1,$(ENABLE_STATIC)),Static,Shared)" | $(if $(filter 0,$(DISPLAY_AS_LOG)),tee -a $(LOGS)/log,cat)
	$(ECHO) "=== Configuration ===" | $(if $(filter 0,$(DISPLAY_AS_LOG)),tee -a $(LOGS)/log,cat)
	$(ECHO) "Edit versions.mk to add or modify targets and components." | $(if $(filter 0,$(DISPLAY_AS_LOG)),tee -a $(LOGS)/log,cat)
	$(ECHO) "Supported targets: $(TARGETS)" | $(if $(filter 0,$(DISPLAY_AS_LOG)),tee -a $(LOGS)/log,cat)
	$(ECHO) "Common components: $(COMMON_COMPONENTS)" | $(if $(filter 0,$(DISPLAY_AS_LOG)),tee -a $(LOGS)/log,cat)
	$(ECHO) "DISPLAY_AS_LOG: $(if $(filter 1,$(DISPLAY_AS_LOG)),Output to screen (no logs),Output to logs)" | $(if $(filter 0,$(DISPLAY_AS_LOG)),tee -a $(LOGS)/log,cat)
	$(ECHO) "=== Status ===" | $(if $(filter 0,$(DISPLAY_AS_LOG)),tee -a $(LOGS)/log,cat)
	$(ECHO) "First Error: $(if $(FIRST_ERROR),$(FIRST_ERROR),None)" | $(if $(filter 0,$(DISPLAY_AS_LOG)),tee -a $(LOGS)/log,cat)
	$(ECHO) "Recent Error: $(if $(RECENT_ERROR),$(RECENT_ERROR),None)" | $(if $(filter 0,$(DISPLAY_AS_LOG)),tee -a $(LOGS)/log,cat)
	$(ECHO) "Last Message: $(if $(LAST_MESSAGE),$(LAST_MESSAGE),None)" | $(if $(filter 0,$(DISPLAY_AS_LOG)),tee -a $(LOGS)/log,cat)
	$(ECHO) "=== Files ===" | $(if $(filter 0,$(DISPLAY_AS_LOG)),tee -a $(LOGS)/log,cat)
	$(foreach pkg,$(sort $(DOWNLOAD_FILES)),$(eval _f := $(wildcard $(pkg))) $(if $(_f),$(ECHO) "\t$(notdir $(pkg)) ($(_f))" | $(if $(filter 0,$(DISPLAY_AS_LOG)),tee -a $(LOGS)/log,cat)))
	$(ECHO) "=== URLs ===" | $(if $(filter 0,$(DISPLAY_AS_LOG)),tee -a $(LOGS)/log,cat)
	@checked=0; up=0; down=0; \
	$(foreach pkg,$(URLS),$(call PARSE_URL,$(pkg)); \
		if [ "$$VERSION" = "git" ]; then \
			if [ -d "$(DOWNLOAD_DIR)/$(TARGET)" ]; then \
				$(ECHO) "\t$$URL [CACHED]" | $(if $(filter 0,$(DISPLAY_AS_LOG)),tee -a $(LOGS)/log,cat); \
			else \
				if [ "$(shell $(CURL) -s -I -m 3 "$$URL" >/dev/null && echo OK)" ]; then \
					$(ECHO) "\t$$URL [OK]" | $(if $(filter 0,$(DISPLAY_AS_LOG)),tee -a $(LOGS)/log,cat); up=$$((up+1)); \
				else \
					$(ECHO) "\t$$URL [FAIL]" | $(if $(filter 0,$(DISPLAY_AS_LOG)),tee -a $(LOGS)/log,cat); down=$$((down+1)); \
				fi; \
				checked=$$((checked+1)); \
			fi; \
		else \
			if [ -n "$(wildcard $(DOWNLOAD_DIR)/$(TARGET))" ]; then \
				$(ECHO) "\t$$URL [CACHED]" | $(if $(filter 0,$(DISPLAY_AS_LOG)),tee -a $(LOGS)/log,cat); \
			else \
				if [ "$(shell $(CURL) -s -I -m 3 "$$URL" >/dev/null && echo OK)" ]; then \
					$(ECHO) "\t$$URL [OK]" | $(if $(filter 0,$(DISPLAY_AS_LOG)),tee -a $(LOGS)/log,cat); up=$$((up+1)); \
				else \
					$(ECHO) "\t$$URL [FAIL]" | $(if $(filter 0,$(DISPLAY_AS_LOG)),tee -a $(LOGS)/log,cat); down=$$((down+1)); \
				fi; \
				checked=$$((checked+1)); \
			fi; \
		fi; \
	); \
	[ $$checked -eq 0 ] && $(ECHO) "  All files cached locally" | $(if $(filter 0,$(DISPLAY_AS_LOG)),tee -a $(LOGS)/log,cat); \
	$(ECHO) "URLs: checked=$$checked, up=$$up, down=$$down" | $(if $(filter 0,$(DISPLAY_AS_LOG)),tee -a $(LOGS)/log,cat)
	$(ECHO) "=== Commands ===" | $(if $(filter 0,$(DISPLAY_AS_LOG)),tee -a $(LOGS)/log,cat)
	$(ECHO) "  make [all|check|$(TARGETS)|clean|clean-download|debug_components|debug_rules|help]$(if $(ENABLE_STATIC),, ENABLE_STATIC=1 for static)" | $(if $(filter 0,$(DISPLAY_AS_LOG)),tee -a $(LOGS)/log,cat)
	$(ECHO) "  Build with uncommon components: make <target> INCLUDE_UNCOMMON=1" | $(if $(filter 0,$(DISPLAY_AS_LOG)),tee -a $(LOGS)/log,cat)
	$(ECHO) "  Override: make PREFIX=/custom/path DISPLAY_AS_LOG=1" | $(if $(filter 0,$(DISPLAY_AS_LOG)),tee -a $(LOGS)/log,cat)
	$(ECHO) "  Start: Run 'make check' to validate, then 'make <target>' for desired targets." | $(if $(filter 0,$(DISPLAY_AS_LOG)),tee -a $(LOGS)/log,cat)
	$(call LOG_MESSAGE,Help command executed. $(if $(filter 0,$(DISPLAY_AS_LOG)),See $(LOGS)/log for details.,Output displayed on screen))